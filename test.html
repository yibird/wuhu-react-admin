<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div class="box">
      <span>这是一段文字</span>
      <div class="watermark"></div>
    </div>
  </body>
</html>
<script>
  function watermark(options) {
    if (
      typeof options !== "object" &&
      options !== null &&
      options !== undefined
    ) {
      throw new Error("options参数错误");
    }
    // 默认配置项
    const defaultOptions = {
      // 水印宽度
      width: 120,
      // 水印高度
      height: 60,
      // 水印旋转角度
      rotate: -30,
      // 水印图片源
      image: "",
      // 水印图片宽度
      imageWidth: 120,
      // 水印图片高度
      imageHeight: 64,
      // 水印图片层级
      zIndex: 2000,
      // 水平间距
      gapX: 24,
      // 垂直间距
      gapY: 48,
      // 文字水印内容
      content: "",
      // 文字大小
      fontSize: 14,
      // 文字颜色
      fontColor: "rgba(0,0,0,.15)",
      // 文字样式
      fontStyle: "normal",
      // 文字字体
      fontFamily: "PingFang SC",
      // 文字粗细
      fontWeight: "normal",
      // 是否全屏水印
      fullPage: false,
    };

    function drawImage(ctx, options) {
      const { imageWidth, imageHeight, ratio, markWidth, markHeight, rotate } =
        options;
      // 创建一个图片对象
      const img = new Image();
      /**
       * 请求图片时是否开启CORS功能。anonymous表示在请求头上携带Origin属性,
       * 但请求不会携带cookie和其他的认证信息。
       */
      img.crossOrigin = "anonymous";
      /**
       * 该属性表示获取资源时的引用方式。"no-referrer"表示HTTP头部信息将不会发送referrer
       */
      img.referrerPolicy = "no-referrer";
      // 设置图片源
      img.src = image;
      /**
       * 监听图片加载完成事件,图片加载完成则通过
       * canvas绘制图片水印
       */
      img.onload = function () {
        /*
         * translate(x,y):将canvas按x点的水平方向、y点垂直方向进行平移变换
         */
        ctx.translate(markWidth / 2, markHeight / 2);
        /**
         * rotate(angle):用于旋转canvas,angle表示旋转的幅度,正数表示顺时针旋转,
         * 负数表示逆时针旋转,旋转公式为:degree * Math.PI / 180。旋转中心点默认是
         * canvas 的起始点,可以通过translate()方法平移改变旋转中心点。
         * translate(markWidth / 2, markHeight / 2)表示以canvas的中心点作为
         * 旋转中心。
         */
        ctx.rotate((Math.PI / 180) * Number(rotate));
        /**
         * drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
         * 用于绘制图像,包含如下参数:
         * - image:绘制到canvaS上下文的元素。元素可以是图片、svg、video、canvas。
         * - sx:需要绘制到目标上下文中的,image的矩形(裁剪)选择框的左上角 X 轴坐标。
         * - sy:需要绘制到目标上下文中的,image的矩形(裁剪)选择框的左上角 Y 轴坐标。
         * - sWidth:需要绘制到目标上下文中的,image 的矩形（裁剪）选择框的宽度。
         * - sHeight:需要绘制到目标上下文中的,image 的矩形（裁剪）选择框的高度。
         * - dx:image 的左上角在目标画布上 X 轴坐标。
         * - dy:image 的左上角在目标画布上 Y 轴坐标。
         * - dWidth:image 在目标画布上绘制的宽度。
         * - dHeight:image 在目标画布上绘制的高度。
         */
        ctx.drawImage(
          img,
          (-imageWidth * ratio) / 2,
          (-imageHeight * ratio) / 2,
          imageWidth * ratio,
          imageHeight * ratio
        );
        // 将canvas恢复到最近一次的保存状态
        ctx.restore();
        const base64Url = canvas.toDataURL();
        setStyle(base64Url, options);
      };
    }
    function drawText(ctx, options) {
      const {
        fontSize,
        fontColor,
        fontStyle,
        fontWeight,
        fontFamily,
        markWidth,
        markHeight,
        rotate,
      } = options;
      const markSize = Number(fontSize) * ratio;
      // 设置文本基线,middle表示文本基线在文本块的中间
      ctx.textBaseline = "middle";
      // 文字对齐方式,center表示居中对齐
      ctx.textAlign = "center";
      // 填充样式
      ctx.fillStyle = fontColor;
      // 设置字体
      ctx.font = `${fontStyle} normal ${fontWeight} ${markSize}px/${markHeight}px ${fontFamily}`;
      // 文字绕中间旋转
      ctx.translate(markWidth / 2, markHeight / 2);
      ctx.rotate((Math.PI / 180) * Number(rotate));
      /**
       * fillText(text, x, y, [maxWidth]):填充文字。
       * - text:渲染的文本内容。
       * - x:渲染文本的x轴坐标。
       * - y:渲染文本的y轴坐标。
       * - maxWidth:绘制的最大宽度,可选。如果指定了值,并且经过计算字符串的
       * 值比最大宽度还要宽,字体为了适应会水平缩放或者使用小号的字体。
       */
      ctx.fillText(content, 0, 0);
      // 将canvas恢复到最近一次的保存状态
      ctx.restore();
      /**
       * toDataURL(type, encoderOptions)用于返回一个包含图片展示的 data URI。
       * data URI即利用base64编码把图片数据翻译成标准ASCII字符,简单来说toDataURL()
       * 将canvas绘制的图片转为base64编码。toDataURL参数如下:
       * - type:转换的图片格式。默认为image/png。
       * - encoderOptions:转换后图片质量。如果图片格式为 image/jpeg 或 image/webp
       * 的情况下,可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围,将会使用
       * 默认值 0.92,其他参数会被忽略。
       */
      const base64Url = canvas.toDataURL();
      setStyle(base64Url, options);
    }

    /**
     * 根据canvas绘制图片的base64编码和配置对象设置样式。
     * 通过CSS background-image 引入绘制图片base64编码实现水印,
     * 由于background-repeat属性的默认为repeat,水印会沿着水平轴和垂直轴
     * 重复;通过background-size属性设置 gapX(水平间距) + width(水印宽度)
     * 实现水印之间的间距。
     * @param {*} base64Url canvas绘制图片的base64编码
     * @param {*} options 配置对象
     */
    function setStyle(base64Url, options) {
      const el = document.getElementsByClassName("watermark")[0];
      if (!el) return;
      const { zIndex, gapX, width, fullPage } = options;
      el.style.zIndex = zIndex;
      el.style.backgroundSize = `${gapX + width}px`;
      el.style.backgroundImage = `url(${base64Url})`;
      /**
       * 判断是否全屏显示水印,如果全屏显示水印则添加watermark-full-page类样式,
       * 注意非全屏显示水印需要将父元素为相对布局,即 position: relative。
       */
      if (fullPage) {
        el.classList.add("watermark-full-page");
      }
    }

    // 创建一个canvas元素
    const canvas = document.createElement("canvas");
    /**
     * 根据canvas获取上下文对象,HTML Canvas API仅支持2d,
     * 若要渲染3d效果请使用Webgl(Three.js是目前最为流行的webgl库)
     */
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      throw new Error("当前环境不支持canvas");
    }
    options = Object.assign(defaultOptions, options);
    const { width, height, gapX, gapY, image, content } = options;

    /*
     * 返回当前显示设备的物理像素分辨率与CSS像素分辨率之比,由于canvas
     * 缩小放大会导致绘制内容模糊,使用window.devicePixelRatio确定应添加
     * 多少额外的像素密度以使图像更清晰。
     */
    const ratio = window.devicePixelRatio || 1;
    // 获取canvas的宽高,即: (水平或垂直间距 + 宽或高) * 像素比
    const canvasWidth = `${(gapX + width) * ratio}px`,
      canvasHeight = `${(gapY + height) * ratio}px`;
    // 设置canvas宽高
    canvas.setAttribute("width", canvasWidth);
    canvas.setAttribute("height", canvasHeight);

    const opts = {
      ...options,
      ratio,
      // 获取蒙层宽
      markWidth: width * ratio,
      // 获取蒙层高
      markHeight: height * ratio,
    };

    // 如果image存在则优先绘制图片水印
    if (image) {
      drawImage(ctx, opts);
    } else if (content) {
      // 如果文字内容存在则绘制文字水印
      drawText(ctx, opts);
    }
  }

  /** ========================================================== */
  const image =
    "https://img11.360buyimg.com/imagetools/jfs/t1/57345/6/20069/8019/62b995cdEd96fef03/51d3302dfeccd1d2.png";
  // 图片水印
  //   watermark({ image });

  // 文字水印
  watermark({
    content: "你是一头猪",
    fullPage: true,
  });
</script>
<style>
  html,
  body {
    position: relative;
    height: 100%;
    width: 100%;
    overflow: hidden;
    display: grid;
    place-items: center;
  }
  .box {
    width: 400px;
    height: 400px;
    border: 1px solid #d2d2d2;
    border-radius: 4px;
    position: relative;
    display: grid;
    place-items: center;
  }
  .watermark {
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    /* 
     * 设置元素永远不会成为鼠标事件target。注意:由于水印层级较高,
     * 避免层级过低的元素无法被点击。
     */
    pointer-events: none;
    background-repeat: repeat;
  }
  .watermark-full-page {
    position: fixed;
  }
</style>
